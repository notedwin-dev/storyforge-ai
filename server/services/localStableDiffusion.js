const axios = require('axios');
const fs = require('fs').promises;
const path = require('path');

class LocalStableDiffusionService {
  constructor() {
    // Default Automatic1111 WebUI endpoint
    this.baseUrl = process.env.AUTOMATIC1111_URL || 'http://127.0.0.1:7860';
    this.enabled = process.env.USE_LOCAL_SD === 'true';
    
    // Model configurations for different styles
    this.styleConfigs = {
      cartoon: {
        model: 'sd_xl_base_1.0.safetensors',
        prompts: {
          positive: 'cartoon style, clean lines, bright colors, comic book art,',
          negative: 'realistic, photograph, photorealistic, blurry, low quality, distorted, nsfw'
        },
        steps: 20,
        cfg_scale: 7.0
      },
      anime: {
        model: 'animagineXLV3_v30.safetensors',
        prompts: {
          positive: 'anime style, cel shaded, detailed character design, manga art,',
          negative: 'realistic, photograph, 3d render, blurry, low quality, distorted, nsfw'
        },
        steps: 25,
        cfg_scale: 8.0
      },
      storybook: {
        model: 'sd_xl_base_1.0.safetensors',
        prompts: {
          positive: 'children\'s book illustration, watercolor, soft colors, storybook art,',
          negative: 'dark, scary, realistic, photograph, blurry, low quality, nsfw'
        },
        steps: 30,
        cfg_scale: 7.5
      },
      realistic: {
        model: 'realvisxlV40.safetensors',
        prompts: {
          positive: 'photorealistic, cinematic lighting, professional photography,',
          negative: 'cartoon, anime, artistic, painting, blurry, low quality, distorted, nsfw'
        },
        steps: 35,
        cfg_scale: 6.0
      }
    };
  }

  async checkConnection() {
    if (!this.enabled) {
      return { 
        success: false, 
        error: 'Local Stable Diffusion is disabled. Set USE_LOCAL_SD=true in .env',
        available: false
      };
    }

    try {
      const response = await axios.get(`${this.baseUrl}/sdapi/v1/options`, {
        timeout: 5000
      });
      
      return {
        success: true,
        message: 'Local Stable Diffusion WebUI is running',
        available: true,
        version: response.data?.version || 'unknown'
      };
    } catch (error) {
      return {
        success: false,
        error: `Cannot connect to Automatic1111 WebUI at ${this.baseUrl}. Make sure it's running with --api flag.`,
        available: false
      };
    }
  }

  async generateStoryboardImage(prompt, style = 'cartoon', sceneId) {
    try {
      console.log(`ðŸŽ¨ Generating local storyboard image for scene: ${sceneId}`);

      // Check if local SD is available
      const connectionCheck = await this.checkConnection();
      if (!connectionCheck.available) {
        throw new Error(connectionCheck.error);
      }

      const config = this.styleConfigs[style] || this.styleConfigs.cartoon;
      const enhancedPrompt = this.enhancePromptForStoryboard(prompt, style);

      const payload = {
        prompt: `${config.prompts.positive} ${enhancedPrompt}`,
        negative_prompt: config.prompts.negative,
        steps: config.steps,
        cfg_scale: config.cfg_scale,
        width: 768,
        height: 432, // 16:9 aspect ratio for storyboards
        sampler_name: "DPM++ 2M Karras",
        batch_size: 1,
        n_iter: 1,
        seed: -1, // Random seed
        restore_faces: false,
        tiling: false,
        enable_hr: false, // High-res fix disabled for speed
        save_images: false,
        send_images: true,
        alwayson_scripts: {}
      };

      console.log(`ðŸ”§ Using config: ${JSON.stringify({
        model: config.model,
        steps: config.steps,
        cfg_scale: config.cfg_scale,
        style: style
      })}`);

      const response = await axios.post(`${this.baseUrl}/sdapi/v1/txt2img`, payload, {
        timeout: 60000, // 60 second timeout
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (!response.data.images || response.data.images.length === 0) {
        throw new Error('No images generated by local Stable Diffusion');
      }

      // Decode base64 image
      const base64Image = response.data.images[0];
      const imageBuffer = Buffer.from(base64Image, 'base64');
      
      // Save image
      const imageUrl = await this.saveImage(imageBuffer, sceneId, style);

      console.log(`âœ… Local storyboard generated successfully for scene: ${sceneId}`);

      return {
        success: true,
        imageUrl,
        sceneId,
        style,
        prompt: enhancedPrompt,
        metadata: {
          steps: config.steps,
          cfg_scale: config.cfg_scale,
          model: config.model,
          generation_time: response.data.info?.generation_time || 'unknown'
        }
      };

    } catch (error) {
      console.error('Local Stable Diffusion generation error:', error);
      
      return {
        success: false,
        error: error.message,
        sceneId,
        style,
        prompt
      };
    }
  }

  enhancePromptForStoryboard(prompt, style) {
    const baseEnhancement = 'high quality, detailed, professional storyboard panel, clear composition, comic book style layout, sequential art';
    return `${prompt}, ${baseEnhancement}`;
  }

  async generateMultipleStoryboards(scenes, style = 'cartoon', characterDNA = null) {
    try {
      console.log(`ðŸŽ¨ Creating local composite storyboard for ${scenes.length} scenes...`);
      
      // Create character description for consistency
      let characterPrompt = '';
      if (characterDNA) {
        characterPrompt = `Main character: ${characterDNA.name}, ${characterDNA.description || characterDNA.personality || 'friendly character'}. `;
        if (characterDNA.traits && characterDNA.traits.length > 0) {
          characterPrompt += `Character traits: ${characterDNA.traits.slice(0, 3).join(', ')}. `;
        }
        if (characterDNA.appearance) {
          characterPrompt += `Appearance: ${characterDNA.appearance}. `;
        }
      }

      // Create a single comprehensive prompt for all scenes
      const allSceneDescriptions = scenes.map((scene, index) => {
        const cameraAngle = scene.camera || 'Medium shot';
        const sceneDescription = scene.storyboardPrompt || scene.description || scene.text || scene.content;
        return `Panel ${index + 1}: ${cameraAngle} - ${characterPrompt}${sceneDescription}`;
      }).join(', ');

      const compositePrompt = `4 panel storyboard layout, ${allSceneDescriptions}`;

      const result = await this.generateStoryboardImage(
        compositePrompt,
        style,
        'storyboard_composite'
      );

      if (result.success) {
        console.log(`âœ… Local composite storyboard generated successfully`);
        return [result.imageUrl];
      } else {
        console.warn(`âš ï¸ Failed to generate local composite storyboard:`, result.error);
        return [];
      }

    } catch (error) {
      console.error('Error in local generateMultipleStoryboards:', error);
      return [];
    }
  }

  async saveImage(imageBuffer, sceneId, style) {
    try {
      const imagesDir = path.join(__dirname, '../uploads/storyboards');
      await fs.mkdir(imagesDir, { recursive: true });
      
      const filename = `local_${sceneId}_${style}_${Date.now()}.png`;
      const filepath = path.join(imagesDir, filename);
      
      await fs.writeFile(filepath, imageBuffer);
      
      return `/uploads/storyboards/${filename}`;
    } catch (error) {
      console.error('Error saving local storyboard image:', error);
      throw new Error('Failed to save local storyboard image');
    }
  }

  // Get available models
  async getAvailableModels() {
    try {
      const response = await axios.get(`${this.baseUrl}/sdapi/v1/sd-models`);
      return response.data.map(model => ({
        name: model.title,
        filename: model.model_name,
        hash: model.hash
      }));
    } catch (error) {
      console.error('Error getting available models:', error);
      return [];
    }
  }

  // Switch model
  async switchModel(modelName) {
    try {
      await axios.post(`${this.baseUrl}/sdapi/v1/options`, {
        sd_model_checkpoint: modelName
      });
      return { success: true, message: `Switched to model: ${modelName}` };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
}

module.exports = { LocalStableDiffusionService };
