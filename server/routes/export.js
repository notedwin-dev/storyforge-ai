const express = require('express');
const { PDFDocument, rgb } = require('pdf-lib');
const path = require('path');
const fs = require('fs').promises;
const { uploadToStorage } = require('../services/storage');
const { requireAuth } = require('../middleware/auth');

const router = express.Router();

// Export story as PDF
router.post('/pdf', async (req, res) => {
  try {
    const { job_id, title, include_images = true } = req.body;

    if (!job_id) {
      return res.status(400).json({
        error: 'Missing job_id',
        message: 'Job ID is required for PDF export'
      });
    }

    console.log(`Exporting PDF for job: ${job_id}`);

    // Load result data
    const resultPath = path.join(__dirname, '../storage/results', `${job_id}.json`);
    const resultData = await fs.readFile(resultPath, 'utf8');
    const result = JSON.parse(resultData);

    // Create PDF
    const pdfDoc = await PDFDocument.create();
    const page = pdfDoc.addPage([595, 842]); // A4 size
    
    const { width, height } = page.getSize();
    let yPosition = height - 50;

    // Title
    const titleText = title || result.story.title || 'StoryForge AI Story';
    page.drawText(titleText, {
      x: 50,
      y: yPosition,
      size: 24,
      color: rgb(0.1, 0.1, 0.1)
    });
    yPosition -= 60;

    // Character info
    page.drawText(`Character: ${result.metadata.character_name}`, {
      x: 50,
      y: yPosition,
      size: 12,
      color: rgb(0.3, 0.3, 0.3)
    });
    yPosition -= 20;

    page.drawText(`Style: ${result.metadata.style} | Genre: ${result.metadata.genre}`, {
      x: 50,
      y: yPosition,
      size: 12,
      color: rgb(0.3, 0.3, 0.3)
    });
    yPosition -= 40;

    // Story content
    if (result.story.scenes && result.story.scenes.length > 0) {
      for (let i = 0; i < result.story.scenes.length; i++) {
        const scene = result.story.scenes[i];
        
        // Scene title
        page.drawText(`Scene ${i + 1}: ${scene.title || `Scene ${i + 1}`}`, {
          x: 50,
          y: yPosition,
          size: 16,
          color: rgb(0.2, 0.2, 0.2)
        });
        yPosition -= 30;

        // Scene description
        const description = scene.description || scene.text || 'No description available';
        const words = description.split(' ');
        let line = '';
        
        for (const word of words) {
          const testLine = line + word + ' ';
          if (testLine.length > 80) { // Approximate character limit per line
            page.drawText(line.trim(), {
              x: 50,
              y: yPosition,
              size: 11,
              color: rgb(0, 0, 0)
            });
            yPosition -= 18;
            line = word + ' ';
          } else {
            line = testLine;
          }
          
          // Check if we need a new page
          if (yPosition < 100) {
            const newPage = pdfDoc.addPage([595, 842]);
            yPosition = height - 50;
          }
        }
        
        if (line.trim()) {
          page.drawText(line.trim(), {
            x: 50,
            y: yPosition,
            size: 11,
            color: rgb(0, 0, 0)
          });
          yPosition -= 30;
        }
      }
    }

    // Footer
    const currentPage = pdfDoc.getPages()[pdfDoc.getPageCount() - 1];
    currentPage.drawText('Generated by StoryForge AI', {
      x: 50,
      y: 30,
      size: 10,
      color: rgb(0.5, 0.5, 0.5)
    });

    currentPage.drawText(new Date().toLocaleDateString(), {
      x: width - 100,
      y: 30,
      size: 10,
      color: rgb(0.5, 0.5, 0.5)
    });

    // Generate PDF buffer
    const pdfBytes = await pdfDoc.save();

    // Upload to S3
    const pdfKey = `exports/${job_id}_storybook.pdf`;
    const pdfUrl = await uploadToStorage(Buffer.from(pdfBytes), pdfKey, 'application/pdf');

    console.log(`PDF exported successfully for job: ${job_id}`);

    res.json({
      success: true,
      pdf_url: pdfUrl,
      filename: `${titleText.replace(/[^a-zA-Z0-9]/g, '_')}_storybook.pdf`,
      size: pdfBytes.length,
      pages: pdfDoc.getPageCount(),
      exported_at: new Date().toISOString()
    });

  } catch (error) {
    console.error('PDF export error:', error);
    res.status(500).json({
      error: 'PDF export failed',
      message: error.message
    });
  }
});

// Export story by ID with format parameter (for frontend compatibility)
router.post('/:storyId', requireAuth, async (req, res) => {
  try {
    const { storyId } = req.params;
    const { format = 'pdf' } = req.query;

    if (format !== 'pdf') {
      return res.status(400).json({
        error: 'Unsupported format',
        message: 'Only PDF format is currently supported'
      });
    }

    console.log(`Exporting PDF for story: ${storyId}`);

    // Load result data
    const resultPath = path.join(__dirname, '../storage/results', `${storyId}.json`);
    
    try {
      const resultData = await fs.readFile(resultPath, 'utf8');
      const result = JSON.parse(resultData);

      // Create PDF using the same logic as the existing /pdf route
      const pdfDoc = await PDFDocument.create();
      const page = pdfDoc.addPage([595, 842]); // A4 size
      
      const { width, height } = page.getSize();
      let yPosition = height - 50;

      // Title
      const titleText = result.story?.title || 'StoryForge AI Story';
      page.drawText(titleText, {
        x: 50,
        y: yPosition,
        size: 24,
        color: rgb(0.1, 0.1, 0.1)
      });
      yPosition -= 60;

      // Character info
      if (result.metadata?.character_name) {
        page.drawText(`Character: ${result.metadata.character_name}`, {
          x: 50,
          y: yPosition,
          size: 12,
          color: rgb(0.3, 0.3, 0.3)
        });
        yPosition -= 20;
      }

      // Style and genre info
      if (result.metadata?.style || result.metadata?.genre) {
        page.drawText(`Style: ${result.metadata?.style || 'Unknown'} | Genre: ${result.metadata?.genre || 'Unknown'}`, {
          x: 50,
          y: yPosition,
          size: 12,
          color: rgb(0.3, 0.3, 0.3)
        });
        yPosition -= 40;
      }

      // Story content
      if (result.story?.scenes && result.story.scenes.length > 0) {
        for (let i = 0; i < result.story.scenes.length; i++) {
          const scene = result.story.scenes[i];
          
          // Scene title
          page.drawText(`Scene ${i + 1}: ${scene.title || `Scene ${i + 1}`}`, {
            x: 50,
            y: yPosition,
            size: 16,
            color: rgb(0.2, 0.2, 0.2)
          });
          yPosition -= 30;

          // Scene content
          const content = scene.content || scene.description || scene.text || 'No content available';
          const words = content.split(' ');
          let line = '';
          
          for (const word of words) {
            const testLine = line + word + ' ';
            if (testLine.length > 80) { // Approximate character limit per line
              page.drawText(line.trim(), {
                x: 50,
                y: yPosition,
                size: 11,
                color: rgb(0, 0, 0)
              });
              yPosition -= 18;
              line = word + ' ';
            } else {
              line = testLine;
            }
            
            // Check if we need a new page
            if (yPosition < 100) {
              const newPage = pdfDoc.addPage([595, 842]);
              yPosition = height - 50;
              page = newPage; // Update current page reference
            }
          }
          
          if (line.trim()) {
            page.drawText(line.trim(), {
              x: 50,
              y: yPosition,
              size: 11,
              color: rgb(0, 0, 0)
            });
            yPosition -= 30;
          }
        }
      } else if (result.story?.content) {
        // Handle single content block
        const content = result.story.content;
        const words = content.split(' ');
        let line = '';
        
        for (const word of words) {
          const testLine = line + word + ' ';
          if (testLine.length > 80) {
            page.drawText(line.trim(), {
              x: 50,
              y: yPosition,
              size: 11,
              color: rgb(0, 0, 0)
            });
            yPosition -= 18;
            line = word + ' ';
          } else {
            line = testLine;
          }
          
          if (yPosition < 100) {
            const newPage = pdfDoc.addPage([595, 842]);
            yPosition = height - 50;
            page = newPage;
          }
        }
        
        if (line.trim()) {
          page.drawText(line.trim(), {
            x: 50,
            y: yPosition,
            size: 11,
            color: rgb(0, 0, 0)
          });
        }
      }

      // Footer
      const currentPage = pdfDoc.getPages()[pdfDoc.getPageCount() - 1];
      currentPage.drawText('Generated by StoryForge AI', {
        x: 50,
        y: 30,
        size: 10,
        color: rgb(0.5, 0.5, 0.5)
      });

      currentPage.drawText(new Date().toLocaleDateString(), {
        x: width - 100,
        y: 30,
        size: 10,
        color: rgb(0.5, 0.5, 0.5)
      });

      // Generate PDF buffer
      const pdfBytes = await pdfDoc.save();

      // Set response headers for PDF download
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${titleText.replace(/[^a-zA-Z0-9]/g, '_')}_story.pdf"`);

      // Send PDF directly as response
      res.send(Buffer.from(pdfBytes));

    } catch (fileError) {
      console.error('Failed to load story result:', fileError);
      return res.status(404).json({
        error: 'Story not found',
        message: 'Could not find the story to export'
      });
    }

  } catch (error) {
    console.error('Export error:', error);
    res.status(500).json({
      error: 'Export failed',
      message: error.message
    });
  }
});

// Generate shareable link
router.post('/share', async (req, res) => {
  try {
    const { job_id, title, description } = req.body;

    if (!job_id) {
      return res.status(400).json({
        error: 'Missing job_id',
        message: 'Job ID is required for sharing'
      });
    }

    const shareId = require('uuid').v4();
    const shareData = {
      id: shareId,
      job_id: job_id,
      title: title || 'Shared StoryForge Story',
      description: description || 'A story created with StoryForge AI',
      created_at: new Date().toISOString(),
      access_count: 0
    };

    // Save share data
    const sharePath = path.join(__dirname, '../storage/shares', `${shareId}.json`);
    await fs.mkdir(path.dirname(sharePath), { recursive: true });
    await fs.writeFile(sharePath, JSON.stringify(shareData, null, 2));

    const shareUrl = `${process.env.FRONTEND_URL || 'http://localhost:5173'}/share/${shareId}`;

    res.json({
      success: true,
      share_id: shareId,
      share_url: shareUrl,
      title: shareData.title,
      created_at: shareData.created_at
    });

  } catch (error) {
    console.error('Share creation error:', error);
    res.status(500).json({
      error: 'Failed to create share link',
      message: error.message
    });
  }
});

// Get shared content
router.get('/share/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const sharePath = path.join(__dirname, '../storage/shares', `${id}.json`);
    const shareData = JSON.parse(await fs.readFile(sharePath, 'utf8'));
    
    // Load the actual result
    const resultPath = path.join(__dirname, '../storage/results', `${shareData.job_id}.json`);
    const result = JSON.parse(await fs.readFile(resultPath, 'utf8'));
    
    // Increment access count
    shareData.access_count++;
    await fs.writeFile(sharePath, JSON.stringify(shareData, null, 2));
    
    res.json({
      success: true,
      share: {
        id: shareData.id,
        title: shareData.title,
        description: shareData.description,
        created_at: shareData.created_at,
        access_count: shareData.access_count
      },
      story: result
    });

  } catch (error) {
    if (error.code === 'ENOENT') {
      return res.status(404).json({
        error: 'Share not found',
        message: 'The shared link does not exist or has expired'
      });
    }
    
    console.error('Share retrieval error:', error);
    res.status(500).json({
      error: 'Failed to load shared content',
      message: error.message
    });
  }
});

module.exports = router;
